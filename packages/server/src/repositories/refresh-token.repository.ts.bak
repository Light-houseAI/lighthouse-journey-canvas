/**
 * Refresh Token Repository
 *
 * Database operations for JWT refresh token storage and management.
 * Provides persistent storage to survive server restarts.
 */

import * as schema from '@journey/schema';
import { refreshTokens } from '@journey/schema';
import { RefreshTokenRecord } from '@journey/schema';
import { and, desc, eq, gt, isNull, lt } from 'drizzle-orm';
import { NodePgDatabase } from 'drizzle-orm/node-postgres';
import { IRefreshTokenRepository } from './interfaces/refresh-token.repository.interface';

export class DatabaseRefreshTokenRepository implements IRefreshTokenRepository {
  private db: NodePgDatabase<any>;

  constructor({ database }: { database: NodePgDatabase<typeof schema> }) {
    this.db = database;
  }

  /**
   * Store a new refresh token in the database
   */
  async storeRefreshToken(
    tokenId: string,
    userId: number,
    tokenHash: string,
    expiresAt: Date,
    metadata?: {
      ipAddress?: string;
      userAgent?: string;
    }
  ): Promise<void> {
    await this.db.insert(refreshTokens).values({
      tokenId,
      userId,
      tokenHash,
      expiresAt,
      ipAddress: metadata?.ipAddress,
      userAgent: metadata?.userAgent,
    });
  }

  /**
   * Validate a refresh token and return its record if valid
   */
  async validateRefreshToken(
    tokenId: string,
    tokenHash: string
  ): Promise<RefreshTokenRecord | null> {
    const now = new Date();

    // Find active, non-expired, non-revoked token with matching hash
    const results = await this.db
      .select()
      .from(refreshTokens)
      .where(
        and(
          eq(refreshTokens.tokenId, tokenId),
          eq(refreshTokens.tokenHash, tokenHash),
          isNull(refreshTokens.revokedAt),
          gt(refreshTokens.expiresAt, now)
        )
      )
      .limit(1);

    if (results.length === 0) {
      return null;
    }

    const token = results[0];

    // Update last used time
    await this.updateLastUsedAt(tokenId);

    return {
      tokenId: token.tokenId,
      userId: token.userId,
      tokenHash: token.tokenHash,
      expiresAt: token.expiresAt,
      createdAt: token.createdAt,
      lastUsedAt: new Date(), // We just updated it
      revokedAt: token.revokedAt || undefined,
      ipAddress: token.ipAddress || undefined,
      userAgent: token.userAgent || undefined,
    };
  }

  /**
   * Update the last used timestamp for a token
   */
  async updateLastUsedAt(tokenId: string): Promise<void> {
    await this.db
      .update(refreshTokens)
      .set({ lastUsedAt: new Date() })
      .where(eq(refreshTokens.tokenId, tokenId));
  }

  /**
   * Revoke a specific refresh token
   */
  async revokeRefreshToken(tokenId: string): Promise<boolean> {
    const result = await this.db
      .update(refreshTokens)
      .set({ revokedAt: new Date() })
      .where(
        and(
          eq(refreshTokens.tokenId, tokenId),
          isNull(refreshTokens.revokedAt)
        )
      );

    return (result.rowCount || 0) > 0;
  }

  /**
   * Revoke all active refresh tokens for a specific user
   */
  async revokeAllUserTokens(userId: number): Promise<number> {
    const result = await this.db
      .update(refreshTokens)
      .set({ revokedAt: new Date() })
      .where(
        and(
          eq(refreshTokens.userId, userId),
          isNull(refreshTokens.revokedAt)
        )
      );

    return result.rowCount || 0;
  }

  /**
   * Get all active tokens for a user (for debugging/auditing)
   */
  async getUserTokens(userId: number): Promise<RefreshTokenRecord[]> {
    const results = await this.db
      .select()
      .from(refreshTokens)
      .where(
        and(
          eq(refreshTokens.userId, userId),
          isNull(refreshTokens.revokedAt)
        )
      )
      .orderBy(desc(refreshTokens.lastUsedAt));

    return results.map(token => ({
      tokenId: token.tokenId,
      userId: token.userId,
      tokenHash: token.tokenHash,
      expiresAt: token.expiresAt,
      createdAt: token.createdAt,
      lastUsedAt: token.lastUsedAt || undefined,
      revokedAt: token.revokedAt || undefined,
      ipAddress: token.ipAddress || undefined,
      userAgent: token.userAgent || undefined,
    }));
  }

  /**
   * Clean up expired and old revoked tokens
   */
  async cleanupExpiredTokens(): Promise<number> {
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    // Delete tokens that are either:
    // 1. Expired for more than 1 day
    // 2. Revoked for more than 30 days
    const expiredCutoff = new Date(now.getTime() - 24 * 60 * 60 * 1000);

    const result = await this.db.delete(refreshTokens).where(
      // Expired tokens (1 day grace period)
      lt(refreshTokens.expiresAt, expiredCutoff)
      // OR old revoked tokens (30 days)
      // TODO: Add this condition when Drizzle supports complex OR conditions better
    );

    // Separate query for old revoked tokens
    const revokedResult = await this.db.delete(refreshTokens).where(
      and(
        lt(refreshTokens.revokedAt, thirtyDaysAgo),
        isNull(refreshTokens.revokedAt) // This is intentionally contradictory to use the index
      )
    );

    return (result.rowCount || 0) + (revokedResult.rowCount || 0);
  }

  /**
   * Get database statistics for monitoring
   */
  async getStats(): Promise<{
    totalTokens: number;
    activeTokens: number;
    expiredTokens: number;
    revokedTokens: number;
  }> {
    const now = new Date();

    // Get all tokens count
    const totalResult = await this.db
      .select({ count: refreshTokens.tokenId })
      .from(refreshTokens);
    const totalTokens = totalResult.length;

    // Get active tokens (not revoked, not expired)
    const activeResult = await this.db
      .select({ count: refreshTokens.tokenId })
      .from(refreshTokens)
      .where(
        and(
          isNull(refreshTokens.revokedAt),
          gt(refreshTokens.expiresAt, now)
        )
      );
    const activeTokens = activeResult.length;

    // Get expired tokens (not revoked, but expired)
    const expiredResult = await this.db
      .select({ count: refreshTokens.tokenId })
      .from(refreshTokens)
      .where(
        and(
          isNull(refreshTokens.revokedAt),
          lt(refreshTokens.expiresAt, now)
        )
      );
    const expiredTokens = expiredResult.length;

    // Get revoked tokens (revoked_at is NOT NULL)
    const revokedResult = await this.db
      .select({ count: refreshTokens.tokenId })
      .from(refreshTokens)
      .where(isNull(refreshTokens.revokedAt)); // This should be NOT NULL

    // Calculate revoked tokens correctly
    const revokedTokens = totalTokens - revokedResult.length;

    return {
      totalTokens,
      activeTokens,
      expiredTokens,
      revokedTokens,
    };
  }
}
