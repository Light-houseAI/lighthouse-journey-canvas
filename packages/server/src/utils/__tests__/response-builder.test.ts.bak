/**
 * Tests for Response Builder Utilities
 *
 * Comprehensive test suite ensuring type-safe response builders work correctly
 * and produce consistent API responses across all scenarios.
 */

import { describe, it, expect, beforeEach } as any from 'vitest';
import {
  createSuccessResponse,
  createErrorResponse,
  createErrorResponseFromError,
  createPaginatedResponse,
  createNotFoundResponse,
  createValidationErrorResponse,
  createUnauthorizedResponse,
  createForbiddenResponse,
  createConflictResponse,
  createCreatedResponse,
  createNoContentResponse,
  ResponseBuilder,
  createResponseBuilder,
  getStatusCodeForResponse,
} from '../response-builder.js';
import {
  ErrorCode,
  HttpStatusCode,
  isSuccessResponse,
  isErrorResponse,
  isPaginatedResponse,
} from '../../core/api-responses';

describe('Response Builder Utilities', () => {
  const testData = { id: 1, name: 'Test Item' } as any;
  const testRequestId = 'req_test_123';

  describe('createSuccessResponse', () => {
    it('should create a basic success response', () => {
      const response = createSuccessResponse(testData);

      expect(response.success).toBe(true);
      expect(response.data).toEqual(testData);
      expect(response.error).toBeUndefined();
      expect(response.meta?.timestamp).toBeDefined();
      expect(new Date(response.meta!.timestamp)).toBeInstanceOf(Date);
    });

    it('should include request ID when provided', () => {
      const response = createSuccessResponse(testData, { requestId: testRequestId } as any);

      expect(response.meta?.requestId).toBe(testRequestId);
    });

    it('should include additional metadata', () => {
      const customMeta = { count: 5, viewingUser: 'testuser' } as any;
      const response = createSuccessResponse(testData, { meta: customMeta } as any);

      expect(response.meta?.count).toBe(5);
      expect(response.meta?.viewingUser).toBe('testuser');
      expect(response.meta?.timestamp).toBeDefined();
    });
  });

  describe('createErrorResponse', () => {
    it('should create a basic error response', () => {
      const message = 'Something went wrong';
      const response = createErrorResponse(message);

      expect(response.success).toBe(false);
      expect(response.data).toBeUndefined();
      expect(response.error?.message).toBe(message);
      expect(response.error?.code).toBe(ErrorCode.INTERNAL_SERVER_ERROR);
      expect(response.meta?.timestamp).toBeDefined();
    });

    it('should use custom error code when provided', () => {
      const response = createErrorResponse('Validation failed', {
        code: ErrorCode.VALIDATION_ERROR,
      });

      expect(response.error?.code).toBe(ErrorCode.VALIDATION_ERROR);
    });

    it('should include error details', () => {
      const details = { field: 'email', reason: 'invalid format' } as any;
      const response = createErrorResponse('Validation failed', {
        code: ErrorCode.VALIDATION_ERROR,
        details,
      });

      expect(response.error?.details).toEqual(details);
    });
  });

  describe('createErrorResponseFromError', () => {
    it('should create error response from Error object', () => {
      const error = new Error('Database connection failed');
      const response = createErrorResponseFromError(error);

      expect(response.success).toBe(false);
      expect(response.error?.message).toBe('Database connection failed');
      expect(response.error?.code).toBe(ErrorCode.INTERNAL_SERVER_ERROR);
    });

    it('should auto-detect validation errors', () => {
      const error = new Error('Invalid input data');
      error.name = 'ValidationError';
      const response = createErrorResponseFromError(error);

      expect(response.error?.code).toBe(ErrorCode.VALIDATION_ERROR);
    });

    it('should auto-detect not found errors', () => {
      const error = new Error('User not found');
      const response = createErrorResponseFromError(error);

      expect(response.error?.code).toBe(ErrorCode.NOT_FOUND);
    });

    it('should include debug details in development', () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'development';

      const error = new Error('Test error');
      error.stack = 'Error stack trace...';
      const response = createErrorResponseFromError(error);

      expect(response.error?.details?.name).toBe('Error');
      expect(response.error?.details?.stack).toBeDefined();

      process.env.NODE_ENV = originalEnv;
    });
  });

  describe('createPaginatedResponse', () => {
    const items = [
      { id: 1, name: 'Item 1' } as any,
      { id: 2, name: 'Item 2' } as any,
    ];

    it('should create a paginated response', () => {
      const response = createPaginatedResponse(items, {
        page: 1,
        limit: 2,
        total: 10,
      });

      expect(response.success).toBe(true);
      expect(response.data).toEqual(items);
      expect(response.meta?.pagination).toEqual({
        page: 1,
        limit: 2,
        total: 10,
        totalPages: 5,
        hasNext: true,
        hasPrev: false,
      });
      expect(response.meta?.count).toBe(2);
    });

    it('should calculate pagination correctly for last page', () => {
      const response = createPaginatedResponse(items, {
        page: 5,
        limit: 2,
        total: 10,
      });

      expect(response.meta?.pagination?.hasNext).toBe(false);
      expect(response.meta?.pagination?.hasPrev).toBe(true);
    });

    it('should handle empty results', () => {
      const response = createPaginatedResponse([], {
        page: 1,
        limit: 10,
        total: 0,
      });

      expect(response.data).toEqual([]);
      expect(response.meta?.count).toBe(0);
      expect(response.meta?.pagination?.totalPages).toBe(0);
    });
  });

  describe('Specialized response creators', () => {
    it('should create not found response', () => {
      const response = createNotFoundResponse('User');

      expect(response.success).toBe(false);
      expect(response.error?.code).toBe(ErrorCode.NOT_FOUND);
      expect(response.error?.message).toBe('User not found');
    });

    it('should create validation error response', () => {
      const details = { errors: ['Field is required'] } as any;
      const response = createValidationErrorResponse('Invalid input', details);

      expect(response.error?.code).toBe(ErrorCode.VALIDATION_ERROR);
      expect(response.error?.details).toEqual(details);
    });

    it('should create unauthorized response', () => {
      const response = createUnauthorizedResponse();

      expect(response.error?.code).toBe(ErrorCode.AUTHENTICATION_REQUIRED);
      expect(response.error?.message).toBe('Authentication required');
    });

    it('should create forbidden response', () => {
      const response = createForbiddenResponse();

      expect(response.error?.code).toBe(ErrorCode.ACCESS_DENIED);
      expect(response.error?.message).toBe('Access denied');
    });

    it('should create conflict response', () => {
      const response = createConflictResponse('Resource already exists');

      expect(response.error?.code).toBe(ErrorCode.RESOURCE_CONFLICT);
      expect(response.error?.message).toBe('Resource already exists');
    });

    it('should create created response', () => {
      const response = createCreatedResponse(testData);

      expect(response.success).toBe(true);
      expect(response.data).toEqual(testData);
    });

    it('should create no content response', () => {
      const response = createNoContentResponse();

      expect(response.success).toBe(true);
      expect(response.data).toBe(null);
    });
  });

  describe('ResponseBuilder class', () => {
    let builder: ResponseBuilder;

    beforeEach(() => {
      builder = createResponseBuilder(testRequestId);
    });

    it('should create success response with fluent API', () => {
      const response = builder.success(testData);

      expect(response.success).toBe(true);
      expect(response.data).toEqual(testData);
      expect(response.meta?.requestId).toBe(testRequestId);
    });

    it('should create error response with fluent API', () => {
      const response = builder.error('Something failed', ErrorCode.VALIDATION_ERROR);

      expect(response.success).toBe(false);
      expect(response.error?.code).toBe(ErrorCode.VALIDATION_ERROR);
      expect(response.meta?.requestId).toBe(testRequestId);
    });

    it('should create paginated response with fluent API', () => {
      const items = [testData];
      const response = builder.paginated(items, 1, 10, 1);

      expect(response.success).toBe(true);
      expect(response.data).toEqual(items);
      expect(response.meta?.pagination).toBeDefined();
      expect(response.meta?.requestId).toBe(testRequestId);
    });

    it('should create error from exception', () => {
      const error = new Error('Test error');
      const response = builder.errorFromException(error);

      expect(response.success).toBe(false);
      expect(response.error?.message).toBe('Test error');
      expect(response.meta?.requestId).toBe(testRequestId);
    });
  });

  describe('getStatusCodeForResponse', () => {
    it('should return 200 for success with data', () => {
      const response = createSuccessResponse(testData);
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.OK);
    });

    it('should return 204 for success with null data', () => {
      const response = createNoContentResponse();
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.NO_CONTENT);
    });

    it('should return 400 for validation errors', () => {
      const response = createValidationErrorResponse('Invalid input');
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.BAD_REQUEST);
    });

    it('should return 401 for authentication errors', () => {
      const response = createUnauthorizedResponse();
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.UNAUTHORIZED);
    });

    it('should return 403 for access denied errors', () => {
      const response = createForbiddenResponse();
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.FORBIDDEN);
    });

    it('should return 404 for not found errors', () => {
      const response = createNotFoundResponse();
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.NOT_FOUND);
    });

    it('should return 409 for conflict errors', () => {
      const response = createConflictResponse('Already exists');
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.CONFLICT);
    });

    it('should return 500 for internal server errors', () => {
      const response = createErrorResponse('Internal error');
      expect(getStatusCodeForResponse(response)).toBe(HttpStatusCode.INTERNAL_SERVER_ERROR);
    });
  });

  describe('Type guards', () => {
    it('should correctly identify success responses', () => {
      const successResponse = createSuccessResponse(testData);
      const errorResponse = createErrorResponse('Error');

      expect(isSuccessResponse(successResponse)).toBe(true);
      expect(isSuccessResponse(errorResponse)).toBe(false);
    });

    it('should correctly identify error responses', () => {
      const successResponse = createSuccessResponse(testData);
      const errorResponse = createErrorResponse('Error');

      expect(isErrorResponse(errorResponse)).toBe(true);
      expect(isErrorResponse(successResponse)).toBe(false);
    });

    it('should correctly identify paginated responses', () => {
      const paginatedResponse = createPaginatedResponse([testData], {
        page: 1,
        limit: 10,
        total: 1,
      });
      const regularResponse = createSuccessResponse([testData]);

      expect(isPaginatedResponse(paginatedResponse)).toBe(true);
      expect(isPaginatedResponse(regularResponse)).toBe(false);
    });
  });

  describe('Edge cases', () => {
    it('should handle empty strings in responses', () => {
      const response = createSuccessResponse('');

      expect(response.success).toBe(true);
      expect(response.data).toBe('');
    });

    it('should handle null data in responses', () => {
      const response = createSuccessResponse(null);

      expect(response.success).toBe(true);
      expect(response.data).toBe(null);
    });

    it('should handle undefined in error details', () => {
      const response = createErrorResponse('Error', { details: undefined } as any);

      expect(response.error?.details).toBeUndefined();
    });

    it('should handle complex nested data', () => {
      const complexData = {
        user: { id: 1, profile: { settings: { theme: 'dark' } as any } },
        items: [{ id: 1 } as any, { id: 2 } as any],
      };
      const response = createSuccessResponse(complexData);

      expect(response.data).toEqual(complexData);
    });
  });
});
