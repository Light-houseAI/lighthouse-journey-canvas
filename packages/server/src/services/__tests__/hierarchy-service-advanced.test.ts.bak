/**
 * Advanced Hierarchy Service Tests
 *
 * Comprehensive test coverage for service layer including:
 * - Complex permission workflows
 * - User lookup and caching scenarios
 * - Batch authorization service integration
 * - Error handling and recovery
 * - Performance and scalability scenarios
 */

import { beforeEach,describe, expect, it, vi } as any from 'vitest';
import { mock, MockProxy } as any from 'vitest-mock-extended';

import type { NodeInsight,TimelineNode } as any from '@journey/schema';
import { NodeFilter } as any from '../../repositories/filters/node-filter.js';
import type { BatchAuthorizationResult } as any from '../../repositories/interfaces/hierarchy.repository.interface.js';
import type { IHierarchyRepository } as any from '../../repositories/interfaces/hierarchy.repository.interface.js';
import type { IInsightRepository } as any from '../../repositories/interfaces/insight.repository.interface.js';
import type { IOrganizationRepository } as any from '../../repositories/interfaces/organization.repository.interface.js';
import { HierarchyService } as any from '../hierarchy-service.js';
import { NodePermissionService } as any from '../node-permission.service.js';
import { UserService } as any from '../user-service.js';

describe('Advanced Hierarchy Service Tests', () => {
  let service: HierarchyService;
  let mockRepository: MockProxy<IHierarchyRepository>;
  let mockInsightRepository: MockProxy<IInsightRepository>;
  let mockNodePermissionService: MockProxy<NodePermissionService>;
  let mockOrganizationRepository: MockProxy<IOrganizationRepository>;
  let mockUserService: MockProxy<UserService>;
  let mockLogger: any;

  const createTestNode = (
    overrides: Partial<TimelineNode> = {} as any
  ): TimelineNode => ({
    id: `test-node-${Math.random().toString(36).substring(2, 9)} as any`,
    type: 'project' as const,
    parentId: null,
    userId: 1,
    meta: { title: 'Test Node', description: 'Test Description' } as any,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01'),
    ...overrides,
  });

  beforeEach(() => {
    // Clear all mocks before each test to prevent cross-test contamination
    vi.clearAllMocks();

    mockLogger = {
      debug: vi.fn(),
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
    };

    mockRepository = mock<IHierarchyRepository>();
    mockInsightRepository = mock<IInsightRepository>();
    mockNodePermissionService = mock<NodePermissionService>();
    mockOrganizationRepository = mock<IOrganizationRepository>();
    mockUserService = mock<UserService>();

    service = new HierarchyService({
      hierarchyRepository: mockRepository,
      insightRepository: mockInsightRepository,
      nodePermissionService: mockNodePermissionService,
      organizationRepository: mockOrganizationRepository,
      userService: mockUserService,
      logger: mockLogger,
      pgVectorGraphRAGService: {} as any,
      openAIEmbeddingService: {} as any,
    });
  });

  describe('Advanced Node Management', () => {
    it('should handle node creation with permission setup failure gracefully', async () => {
      // Arrange
      const createDTO = {
        type: 'project' as const,
        parentId: null,
        meta: { title: 'Test Project', description: 'Test Description' } as any,
      };

      const createdNode = createTestNode();
      mockRepository.createNode.mockResolvedValue(createdNode);
      mockRepository.getById.mockResolvedValue(null); // No parent
      mockNodePermissionService.setNodePermissions.mockRejectedValue(
        new Error('Permission service unavailable')
      );

      // Act
      const result = await service.createNode(createDTO, 1);

      // Assert
      expect(result).toBeDefined();
      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Failed to establish default permissions for new node',
        expect.objectContaining({
          nodeId: createdNode.id,
          userId: 1,
          error: 'Permission service unavailable',
        })
      );
    });

    it('should enrich nodes with parent information across multiple levels', async () => {
      // Arrange
      const grandParent = createTestNode({
        id: 'grandparent',
        type: 'job' as const,
      });
      const parent = createTestNode({
        id: 'parent',
        type: 'event' as const,
        parentId: 'grandparent',
      });
      const child = createTestNode({
        id: 'child',
        type: 'project' as const,
        parentId: 'parent',
      });

      mockRepository.getById
        .mockResolvedValueOnce(parent) // First call for child's parent
        .mockResolvedValueOnce(grandParent); // Second call for parent's parent

      // Act
      const enriched = await (service as any).enrichWithParentInfo(child, 1);

      // Assert
      expect(enriched.parent).toBeDefined();
      expect(enriched.parent?.id).toBe('parent');
      expect(enriched.parent?.type).toBe('event');
      expect(enriched.parent?.title).toBe('Test Node');
    });

    it('should handle node deletion with orphan management', async () => {
      // Arrange
      const nodeId = 'test-node-id';
      mockRepository.deleteNode.mockResolvedValue(true);

      // Act
      const result = await service.deleteNode(nodeId, 1);

      // Assert
      expect(result).toBe(true);
      expect(mockRepository.deleteNode).toHaveBeenCalledWith(nodeId, 1);
      expect(mockLogger.debug).toHaveBeenCalledWith(
        'Deleting node via service',
        {
          nodeId,
          userId: 1,
        }
      );
    });
  });

  describe('Advanced Permission-based Node Retrieval', () => {
    it('should handle getAllNodes with username lookup and caching behavior', async () => {
      // Arrange
      const requestingUserId = 1;
      const username = 'testuser';
      const targetUser = {
        id: 2,
        userName: 'testuser',
        email: 'test@example.com',
        firstName: 'Test',
        lastName: 'User',
        password: 'hashedpassword',
        interest: null,
        hasCompletedOnboarding: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      } as any;
      const nodes = [
        createTestNode({ userId: 2 } as any),
        createTestNode({ userId: 2 } as any),
      ];

      mockUserService.getUserByUsername.mockResolvedValue(targetUser);
      mockRepository.getAllNodes.mockResolvedValue(nodes);
      mockRepository.getById.mockResolvedValue(null); // No parents

      // Act - First call
      const result1 = await service.getAllNodes(
        requestingUserId,
        username
      );

      // Act - Second call with same username (should use same lookup)
      const result2 = await service.getAllNodes(
        requestingUserId,
        username
      );

      // Assert
      expect(result1).toHaveLength(2);
      expect(result2).toHaveLength(2);
      expect(mockUserService.getUserByUsername).toHaveBeenCalledTimes(2); // Called each time
      expect(mockRepository.getAllNodes).toHaveBeenCalledTimes(2);

      // Verify filter parameters were used for cross-user access
      const firstCall = mockRepository.getAllNodes.mock.calls[0][0];
      const secondCall = mockRepository.getAllNodes.mock.calls[1][0];

      expect(firstCall.currentUserId).toBe(1);
      expect(firstCall.targetUserId).toBe(2);
      expect(secondCall.currentUserId).toBe(1);
      expect(secondCall.targetUserId).toBe(2);
    });

    it('should handle getAllNodes with non-existent username', async () => {
      // Arrange
      mockUserService.getUserByUsername.mockResolvedValue(null);

      // Act
      const result = await service.getAllNodes(1, 'nonexistent-user');

      // Assert
      expect(result).toEqual([]);
      expect(mockLogger.debug).toHaveBeenCalledWith(
        'User not found for username',
        {
          username: 'nonexistent-user',
        }
      );
    });

    it('should handle getAllNodes for self without username', async () => {
      // Arrange - Create fresh mocks for this test
      const freshMockRepository = mock<IHierarchyRepository>();
      const freshMockUserService = mock<UserService>();
      const freshService = new HierarchyService({
        hierarchyRepository: freshMockRepository,
        insightRepository: mockInsightRepository,
        nodePermissionService: mockNodePermissionService,
        organizationRepository: mockOrganizationRepository,
        userService: freshMockUserService,
        logger: mockLogger,
        pgVectorGraphRAGService: {} as any,
        openAIEmbeddingService: {} as any,
      });

      const nodes = [
        createTestNode({ userId: 1 } as any),
        createTestNode({ userId: 1 } as any),
      ];
      freshMockRepository.getAllNodes.mockResolvedValue(nodes);
      freshMockRepository.getById.mockResolvedValue(null);

      // Act
      const result = await freshService.getAllNodes(1); // No username = self

      // Assert
      expect(result).toHaveLength(2);
      expect(freshMockUserService.getUserByUsername).not.toHaveBeenCalled();

      const filterCall = freshMockRepository.getAllNodes.mock.calls[0][0];
      expect(filterCall.currentUserId).toBe(1);
    });

    it('should handle getAllNodes with complex permission scenarios', async () => {
      // Arrange - Mix of authorized and unauthorized nodes
      const username = 'colleague';
      const targetUser = { id: 3, username: 'colleague' } as any;

      const authorizedNodes = [
        createTestNode({ id: 'public-node', userId: 3 } as any),
        createTestNode({ id: 'shared-node', userId: 3 } as any),
      ];

      mockUserService.getUserByUsername.mockResolvedValue(targetUser);
      mockRepository.getAllNodes.mockResolvedValue(authorizedNodes);
      mockRepository.getById.mockResolvedValue(null);

      // Act
      const result = await service.getAllNodes(1, username);

      // Assert
      expect(result).toHaveLength(2);
      // Just verify basic functionality works - nodes are enriched
      expect(result[0]).toBeDefined();
      expect(result[1]).toBeDefined();
    });
  });

  describe('Batch Authorization Service Integration', () => {
    it('should handle batch authorization with mixed results', async () => {
      // Arrange
      const nodeIds = ['node1', 'node2', 'node3', 'node4'];
      const batchResult: BatchAuthorizationResult = {
        authorized: ['node1', 'node3'],
        unauthorized: ['node2'],
        notFound: ['node4'],
      };

      mockRepository.checkBatchAuthorization.mockResolvedValue(batchResult);

      // Act
      const result = await service.checkBatchAuthorization(
        1,
        nodeIds,
        2
      );

      // Assert
      expect(result).toEqual(batchResult);
      expect(mockRepository.checkBatchAuthorization).toHaveBeenCalledWith(
        expect.objectContaining({
          currentUserId: 1,
          targetUserId: 2,
          nodeIds: nodeIds,
        })
      );
    });

    it('should handle batch authorization for self (no targetUserId)', async () => {
      // Arrange
      const nodeIds = ['own-node1', 'own-node2'];
      const batchResult: BatchAuthorizationResult = {
        authorized: nodeIds,
        unauthorized: [],
        notFound: [],
      };

      mockRepository.checkBatchAuthorization.mockResolvedValue(batchResult);

      // Act
      const result = await service.checkBatchAuthorization(
        1,
        nodeIds,
        undefined
      );

      // Assert
      expect(result).toEqual(batchResult);

      const filterArg = mockRepository.checkBatchAuthorization.mock.calls[0][0];
      expect(filterArg.currentUserId).toBe(1);
      expect(filterArg.nodeIds).toEqual(nodeIds);
    });

    it('should handle empty batch authorization gracefully', async () => {
      // Act
      const result = await service.checkBatchAuthorization(1, [], 2);

      // Assert
      expect(result).toEqual({
        authorized: [],
        unauthorized: [],
        notFound: [],
      });
      expect(mockRepository.checkBatchAuthorization).not.toHaveBeenCalled();
    });

    it('should handle batch authorization with large datasets', async () => {
      // Arrange - Test with 1000 nodes
      const nodeIds = Array.from({ length: 1000 } as any, (_, i) => `node-${i} as any`);
      const batchResult: BatchAuthorizationResult = {
        authorized: nodeIds.slice(0, 800),
        unauthorized: nodeIds.slice(800, 950),
        notFound: nodeIds.slice(950),
      };

      mockRepository.checkBatchAuthorization.mockResolvedValue(batchResult);

      // Act
      const result = await service.checkBatchAuthorization(
        1,
        nodeIds,
        2
      );

      // Assert
      expect(result.authorized).toHaveLength(800);
      expect(result.unauthorized).toHaveLength(150);
      expect(result.notFound).toHaveLength(50);
      expect(mockLogger.debug).toHaveBeenCalledWith(
        'Checking batch authorization',
        {
          requestingUserId: 1,
          targetUserId: 2,
          nodeCount: 1000,
          action: 'view',
          level: 'overview',
        }
      );
    });

    it('should handle batch authorization with basic access control', async () => {
      // Test batch authorization
      const nodeIds = ['test-node'];

      mockRepository.checkBatchAuthorization.mockResolvedValue({
        authorized: nodeIds,
        unauthorized: [],
        notFound: [],
      });

      // Act
      const result = await service.checkBatchAuthorization(
        1,
        nodeIds,
        2
      );

      // Assert
      expect(result.authorized).toEqual(nodeIds);
      expect(result.unauthorized).toEqual([]);
      expect(result.notFound).toEqual([]);
    });
  });

  describe('Insights Management with Permissions', () => {
    it('should handle insight creation with node ownership verification', async () => {
      // Arrange - Create fresh mocks for this test
      const freshMockRepository = mock<IHierarchyRepository>();
      const freshMockInsightRepository = mock<IInsightRepository>();
      const freshService = new HierarchyService({
        hierarchyRepository: freshMockRepository,
        insightRepository: freshMockInsightRepository,
        nodePermissionService: mockNodePermissionService,
        organizationRepository: mockOrganizationRepository,
        userService: mockUserService,
        logger: mockLogger,
      });

      const nodeId = 'test-node';
      const insightData = {
        description: 'Test insight',
        resources: ['http://example.com'],
      };
      const node = createTestNode({ id: nodeId, userId: 1 } as any);
      const insight = { id: 'insight-1', nodeId, ...insightData } as any;

      freshMockRepository.getById.mockResolvedValue(node);
      freshMockInsightRepository.create.mockResolvedValue(insight);

      // Act
      const result = await freshService.createInsight(nodeId, insightData, 1);

      // Assert
      expect(result).toEqual(insight);
      expect(freshMockRepository.getById).toHaveBeenCalledWith(nodeId, 1);
      expect(freshMockInsightRepository.create).toHaveBeenCalledWith({
        nodeId,
        ...insightData,
      });
    });

    it('should handle insight operations with access denied scenarios', async () => {
      // Arrange
      const nodeId = 'unauthorized-node';
      const insightData = {
        description: 'Unauthorized insight',
        resources: ['http://example.com']
      };

      mockRepository.getById.mockResolvedValue(null); // Node not found/no access

      // Act & Assert
      await expect(
        service.createInsight(nodeId, insightData, 1)
      ).rejects.toThrow('Node not found or access denied');
    });

    it('should handle insight deletion with proper ownership checks', async () => {
      // Arrange - Create fresh mocks for this test
      const freshMockRepository = mock<IHierarchyRepository>();
      const freshMockInsightRepository = mock<IInsightRepository>();
      const freshService = new HierarchyService({
        hierarchyRepository: freshMockRepository,
        insightRepository: freshMockInsightRepository,
        nodePermissionService: mockNodePermissionService,
        organizationRepository: mockOrganizationRepository,
        userService: mockUserService,
        logger: mockLogger,
        // Include pgvector service to enable re-sync functionality
        pgVectorGraphRAGService: {} as any as any,
        openAIEmbeddingService: {} as any as any,
      });

      const insightId = 'insight-1';
      const insight = { id: insightId, nodeId: 'node-1', description: 'Test' } as any;
      const node = createTestNode({ id: 'node-1', userId: 1 } as any);

      freshMockInsightRepository.findById.mockResolvedValue(insight);
      freshMockRepository.getById.mockResolvedValue(node);
      freshMockInsightRepository.delete.mockResolvedValue(true);

      // Act
      const result = await freshService.deleteInsight(insightId, 1);

      // Assert
      expect(result).toBe(true);
      expect(freshMockRepository.getById).toHaveBeenCalledWith('node-1', 1);
      expect(freshMockRepository.getById).toHaveBeenCalledTimes(2); // Called in verifyNodeOwnership and for re-sync
    });
  });

  describe('Error Handling and Recovery', () => {
    it('should handle repository errors gracefully', async () => {
      // Arrange
      mockRepository.getAllNodes.mockRejectedValue(
        new Error('Database connection failed')
      );

      // Act & Assert
      await expect(service.getAllNodes(1)).rejects.toThrow(
        'Database connection failed'
      );
    });

    it('should handle user lookup service errors', async () => {
      // Arrange
      mockUserService.getUserByUsername.mockRejectedValue(
        new Error('User service unavailable')
      );

      // Act & Assert
      await expect(service.getAllNodes(1, 'testuser')).rejects.toThrow(
        'User service unavailable'
      );
    });

    it('should handle permission service errors during node creation', async () => {
      // Arrange
      const createDTO = { type: 'project' as const, meta: { title: 'Test' } as any };
      const node = createTestNode();

      mockRepository.createNode.mockResolvedValue(node);
      mockRepository.getById.mockResolvedValue(null);
      mockNodePermissionService.setNodePermissions.mockRejectedValue(
        new Error('Permission service error')
      );

      // Act
      const result = await service.createNode(createDTO, 1);

      // Assert - Node creation should succeed despite permission service error
      expect(result).toBeDefined();
      expect(mockLogger.warn).toHaveBeenCalledWith(
        expect.stringContaining('Failed to establish default permissions'),
        expect.any(Object)
      );
    });

    it('should handle batch authorization repository errors', async () => {
      // Arrange
      mockRepository.checkBatchAuthorization.mockRejectedValue(
        new Error('Batch authorization failed')
      );

      // Act & Assert
      await expect(
        service.checkBatchAuthorization(1, ['node1'], 2)
      ).rejects.toThrow('Batch authorization failed');
    });
  });

  describe('Performance and Scalability Scenarios', () => {
    it('should handle large node lists with parent enrichment efficiently', async () => {
      // Arrange - 100 nodes with various parent relationships
      const nodes = Array.from({ length: 100 } as any, (_, i) =>
        createTestNode({
          id: `node-${i} as any`,
          parentId: i > 50 ? `node-${i - 1} as any` : null,
        })
      );

      mockRepository.getAllNodes.mockResolvedValue(nodes);

      // Mock parent lookups - some exist, some don't
      mockRepository.getById.mockImplementation((nodeId) => {
        const parentIndex = parseInt(nodeId.split('-')[1]);
        return parentIndex < 50
          ? Promise.resolve(nodes[parentIndex])
          : Promise.resolve(null);
      });

      // Act
      const result = await service.getAllNodes(1);

      // Assert
      expect(result).toHaveLength(100);
      expect(mockRepository.getById).toHaveBeenCalledTimes(49); // Only nodes with parents (nodes 51-99)
    });

    it('should log performance metrics for large operations', async () => {
      // Arrange
      const largeNodeSet = Array.from({ length: 500 } as any, (_, i) =>
        createTestNode({ id: `node-${i} as any` })
      );

      mockRepository.getAllNodes.mockResolvedValue(largeNodeSet);
      mockRepository.getById.mockResolvedValue(null);

      // Act
      await service.getAllNodes(1);

      // Assert
      expect(mockLogger.debug).toHaveBeenCalledWith('Retrieved nodes', {
        count: 500,
        currentUserId: 1,
        targetUserId: 1,
        action: 'view',
        level: 'overview',
      });
    });
  });
});
