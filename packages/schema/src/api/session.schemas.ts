/**
 * Session API Schemas (LIG-247: Desktop Session to Work Track Mapping)
 *
 * Zod schemas for session push, classification, and feedback APIs.
 * These schemas define the contract between desktop app and backend.
 */

import { z } from 'zod';

import {
  SessionFeedbackType,
  SessionMappingAction,
  TimelineNodeType,
  WorkTrackCategory,
} from '../enums';

// ============================================================================
// SESSION CHAPTER SCHEMAS (from desktop app's generated summary)
// ============================================================================

/**
 * Granular step within a chapter
 */
export const granularStepSchema = z.object({
  step_id: z.number().optional(),
  description: z.string(),
  timestamp: z.string().optional(),
  app: z.string().optional(),
});

/**
 * Chapter in a session summary (intent-based grouping of activities)
 */
export const sessionChapterSchema = z.object({
  chapter_id: z.number(),
  title: z.string(),
  summary: z.string(),
  primary_app: z.string().optional(),
  time_start: z.string().optional(),
  time_end: z.string().optional(),
  granular_steps: z.array(granularStepSchema).optional(),
});

/**
 * Session summary generated by desktop app's AI analysis
 */
export const sessionSummarySchema = z.object({
  highLevelSummary: z.string(),
  chapters: z.array(sessionChapterSchema),
});

export type SessionChapter = z.infer<typeof sessionChapterSchema>;
export type SessionSummary = z.infer<typeof sessionSummarySchema>;
export type GranularStep = z.infer<typeof granularStepSchema>;

// ============================================================================
// PUSH SESSION API SCHEMAS
// ============================================================================

/**
 * Request schema for pushing a session from desktop app
 * This is what the desktop app sends when user clicks "Push Session"
 */
export const pushSessionRequestSchema = z.object({
  // From desktop app (existing payload structure)
  sessionId: z.string().min(1, 'Session ID is required'),
  workflowName: z.string().min(1, 'Workflow name is required'),
  startTime: z.number().positive('Start time must be a positive timestamp'),
  endTime: z.number().positive('End time must be a positive timestamp'),

  // AI-generated summary from desktop app's screenshot analysis
  summary: sessionSummarySchema,

  // Apps used during the session
  appsUsed: z.array(z.string()).optional().default([]),

  // User edits to the summary (if any)
  userEdits: z.record(z.any()).optional(),

  // Optional: User pre-selected node (current manual flow)
  // If provided, we use this directly instead of auto-matching
  journeyNodeId: z.string().uuid().optional(),
  projectId: z.string().uuid().optional(),

  // Optional: Desktop app can suggest a category based on local analysis
  suggestedCategory: z.nativeEnum(WorkTrackCategory).optional(),
});

export type PushSessionRequest = z.infer<typeof pushSessionRequestSchema>;

/**
 * Classification result returned in push response
 */
export const classificationResultSchema = z.object({
  category: z.nativeEnum(WorkTrackCategory),
  confidence: z.number().min(0).max(1),
  nodeType: z.nativeEnum(TimelineNodeType),
  signals: z.array(z.string()), // What triggered this classification
});

export type ClassificationResult = z.infer<typeof classificationResultSchema>;

/**
 * Timeline node summary for response
 */
export const nodeInfoSchema = z.object({
  id: z.string().uuid(),
  type: z.nativeEnum(TimelineNodeType),
  title: z.string(),
  meta: z.record(z.any()).optional(),
});

export type NodeInfo = z.infer<typeof nodeInfoSchema>;

/**
 * Node mapping result returned in push response
 */
export const nodeMappingResultSchema = z.object({
  action: z.nativeEnum(SessionMappingAction),
  nodeId: z.string().uuid(),
  node: nodeInfoSchema.optional(),
  confidence: z.number().min(0).max(1),
  alternativeNodes: z.array(nodeInfoSchema).optional(), // Top 3 alternatives for user review
});

export type NodeMappingResult = z.infer<typeof nodeMappingResultSchema>;

/**
 * Response schema for push session endpoint
 */
export const pushSessionResponseSchema = z.object({
  success: z.boolean(),
  sessionMappingId: z.string().uuid(),

  // Classification result
  classification: classificationResultSchema,

  // Node mapping result
  nodeMapping: nodeMappingResultSchema,

  // For web viewing
  journeyUrl: z.string().url().optional(),
  message: z.string(),
});

export type PushSessionResponse = z.infer<typeof pushSessionResponseSchema>;

// ============================================================================
// RECLASSIFY/REMAP API SCHEMAS
// ============================================================================

/**
 * Request to reclassify a session into a different category
 */
export const reclassifySessionRequestSchema = z.object({
  newCategory: z.nativeEnum(WorkTrackCategory),
  reason: z.string().max(500).optional(), // For RLHF learning
});

export type ReclassifySessionRequest = z.infer<
  typeof reclassifySessionRequestSchema
>;

/**
 * Request to remap a session to a different node
 */
export const remapSessionRequestSchema = z.object({
  newNodeId: z.string().uuid(),
  reason: z.string().max(500).optional(), // For RLHF learning
});

export type RemapSessionRequest = z.infer<typeof remapSessionRequestSchema>;

/**
 * Response for reclassify/remap operations
 */
export const sessionUpdateResponseSchema = z.object({
  success: z.boolean(),
  sessionMappingId: z.string().uuid(),
  feedbackId: z.string().uuid(), // ID of the feedback record created
  message: z.string(),
});

export type SessionUpdateResponse = z.infer<typeof sessionUpdateResponseSchema>;

// ============================================================================
// SESSION LIST/GET API SCHEMAS
// ============================================================================

/**
 * Query parameters for listing sessions
 */
export const listSessionsQuerySchema = z.object({
  page: z.coerce.number().positive().default(1),
  limit: z.coerce.number().positive().max(100).default(20),
  category: z.nativeEnum(WorkTrackCategory).optional(),
  nodeId: z.string().uuid().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
});

export type ListSessionsQuery = z.infer<typeof listSessionsQuerySchema>;

/**
 * Session mapping item in list response
 */
export const sessionMappingItemSchema = z.object({
  id: z.string().uuid(),
  desktopSessionId: z.string(),
  category: z.nativeEnum(WorkTrackCategory),
  categoryConfidence: z.number().nullable(),
  nodeId: z.string().uuid().nullable(),
  nodeTitle: z.string().optional(),
  nodeType: z.nativeEnum(TimelineNodeType).optional(),
  workflowName: z.string().nullable(),
  highLevelSummary: z.string().nullable(),
  startedAt: z.string().datetime().nullable(),
  endedAt: z.string().datetime().nullable(),
  durationSeconds: z.number().nullable(),
  mappingAction: z.nativeEnum(SessionMappingAction).nullable(),
  createdAt: z.string().datetime(),
});

export type SessionMappingItem = z.infer<typeof sessionMappingItemSchema>;

/**
 * Response for listing sessions
 */
export const listSessionsResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    sessions: z.array(sessionMappingItemSchema),
    pagination: z.object({
      page: z.number(),
      limit: z.number(),
      total: z.number(),
      hasNext: z.boolean(),
      hasPrev: z.boolean(),
    }),
  }),
});

export type ListSessionsResponse = z.infer<typeof listSessionsResponseSchema>;

// ============================================================================
// CATEGORIES API SCHEMAS
// ============================================================================

/**
 * Category definition for UI display
 */
export const categoryDefinitionSchema = z.object({
  value: z.nativeEnum(WorkTrackCategory),
  label: z.string(),
  nodeType: z.nativeEnum(TimelineNodeType),
  group: z.string(),
});

export type CategoryDefinition = z.infer<typeof categoryDefinitionSchema>;

/**
 * Response for categories endpoint
 */
export const categoriesResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    categories: z.array(categoryDefinitionSchema),
    groups: z.array(
      z.object({
        key: z.string(),
        label: z.string(),
        categories: z.array(z.nativeEnum(WorkTrackCategory)),
      })
    ),
  }),
});

export type CategoriesResponse = z.infer<typeof categoriesResponseSchema>;

// ============================================================================
// FEEDBACK API SCHEMAS
// ============================================================================

/**
 * Request to submit RLHF feedback
 */
export const submitFeedbackRequestSchema = z.object({
  sessionMappingId: z.string().uuid(),
  feedbackType: z.nativeEnum(SessionFeedbackType),
  originalCategory: z.nativeEnum(WorkTrackCategory),
  correctedCategory: z.nativeEnum(WorkTrackCategory).optional(),
  originalNodeId: z.string().uuid().optional(),
  correctedNodeId: z.string().uuid().optional(),
  userRole: z.string().max(100).optional(),
  reason: z.string().max(500).optional(),
});

export type SubmitFeedbackRequest = z.infer<typeof submitFeedbackRequestSchema>;

/**
 * Response for feedback submission
 */
export const submitFeedbackResponseSchema = z.object({
  success: z.boolean(),
  feedbackId: z.string().uuid(),
  message: z.string(),
});

export type SubmitFeedbackResponse = z.infer<
  typeof submitFeedbackResponseSchema
>;

// ============================================================================
// NODE SESSIONS API SCHEMAS
// ============================================================================

/**
 * Query params for getting sessions by node
 */
export const nodeSessionsQuerySchema = z.object({
  page: z.coerce.number().positive().default(1),
  limit: z.coerce.number().positive().max(50).default(10),
});

export type NodeSessionsQuery = z.infer<typeof nodeSessionsQuerySchema>;

/**
 * Response for getting sessions mapped to a node
 */
export const nodeSessionsResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    nodeId: z.string().uuid(),
    sessions: z.array(sessionMappingItemSchema),
    totalDurationSeconds: z.number(),
    sessionCount: z.number(),
    pagination: z.object({
      page: z.number(),
      limit: z.number(),
      total: z.number(),
      hasNext: z.boolean(),
      hasPrev: z.boolean(),
    }),
  }),
});

export type NodeSessionsResponse = z.infer<typeof nodeSessionsResponseSchema>;

