/**
 * Session API Schemas (LIG-247: Desktop Session to Work Track Mapping)
 *
 * Zod schemas for session push, classification, and feedback APIs.
 * These schemas define the contract between desktop app and backend.
 */

import { z } from 'zod';

import {
  SessionFeedbackType,
  SessionMappingAction,
  TimelineNodeType,
  TrackTemplateType,
  WorkTrackArchetype,
  WorkTrackCategory,
} from '../enums';

// ============================================================================
// SESSION CHAPTER SCHEMAS (from desktop app's generated summary)
// ============================================================================

/**
 * Granular step within a chapter
 */
export const granularStepSchema = z.object({
  step_id: z.number().optional(),
  description: z.string(),
  timestamp: z.string().optional(),
  app: z.string().optional(),
});

/**
 * Chapter in a session summary (intent-based grouping of activities)
 */
export const sessionChapterSchema = z.object({
  chapter_id: z.number(),
  title: z.string(),
  summary: z.string(),
  primary_app: z.string().optional().nullable(),
  time_start: z.string().optional().nullable(),
  time_end: z.string().optional().nullable(),
  granular_steps: z.array(granularStepSchema).optional(),
});

/**
 * Session summary generated by desktop app's AI analysis
 */
export const sessionSummarySchema = z.object({
  highLevelSummary: z.string(),
  chapters: z.array(sessionChapterSchema),
});

export type SessionChapter = z.infer<typeof sessionChapterSchema>;
export type SessionSummary = z.infer<typeof sessionSummarySchema>;
export type GranularStep = z.infer<typeof granularStepSchema>;

// ============================================================================
// SESSION SUMMARY V2 SCHEMAS (Workflow-Centric with 4-Tier Classification)
// ============================================================================

/**
 * Agentic pattern types for AI tool interactions
 */
export const agenticPatternSchema = z.enum([
  'The Architect',   // Planning: Uses AI to generate specs, outlines, or todo lists
  'The Operator',    // Code Generation: Uses AI to write bulk code/text
  'The Reviewer',    // Debugging/Reflection: Pastes errors/drafts for critique
  'The Centaur',     // Tight Loop: Rapidly switches AI<->IDE in <30s intervals
]);

export type AgenticPattern = z.infer<typeof agenticPatternSchema>;

/**
 * Workflow classification - 5-tier hierarchy for comparability
 */
export const workflowClassificationSchema = z.object({
  // Level 1: INTENT (The "Why") - Universal across all knowledge workers
  level_1_intent: z.string(),
  // Level 2: PROBLEM (The "What") - Domain specific obstacle/challenge
  level_2_problem: z.string(),
  // Level 3: APPROACH (The "How") - Methodology pattern (not tools)
  level_3_approach: z.string(),
  // Level 4: TOOLS (The "Where") - Specific applications used
  level_4_tools: z.array(z.string()),
  // Level 5: OUTCOME (The "Result") - Success/completion state of the workflow
  level_5_outcome: z.string(),
  // Comparability type for analytics
  workflow_type: z.enum(['EXTERNALLY_COMPARABLE', 'INTERNALLY_COMPARABLE', 'UNIQUE']),
});

export type WorkflowClassification = z.infer<typeof workflowClassificationSchema>;

/**
 * Semantic step - clustered granular actions (5-10 raw actions = 1 semantic step)
 */
export const semanticStepSchema = z.object({
  step_name: z.string(),
  duration_seconds: z.number(),
  tools_involved: z.array(z.string()),
  description: z.string(),
  raw_action_count: z.number().nullish(),
  agentic_pattern: agenticPatternSchema.nullish(),
});

export type SemanticStep = z.infer<typeof semanticStepSchema>;

/**
 * Inefficiency detected during workflow execution
 */
export const workflowInefficiencySchema = z.object({
  type: z.string(),
  detected_at: z.string(),
  description: z.string(),
  time_lost_seconds: z.number(),
});

export type WorkflowInefficiency = z.infer<typeof workflowInefficiencySchema>;

/**
 * AI-generated recommendation for workflow improvement
 */
export const workflowRecommendationSchema = z.object({
  title: z.string(),
  description: z.string(),
  confidence_score: z.number().min(0).max(1),
  impact_score: z.enum(['HIGH', 'MEDIUM', 'LOW']),
  estimated_time_savings_minutes: z.number().optional(),
});

export type WorkflowRecommendation = z.infer<typeof workflowRecommendationSchema>;

/**
 * Comparison signature for workflow deduplication and fuzzy matching
 */
export const comparisonSignatureSchema = z.object({
  // Normalized string sequence of semantic steps (e.g., 'search->copy->edit->test')
  step_hash: z.string(),
  // Complexity score 1-10 based on step count and tool diversity
  complexity_score: z.number().min(1).max(10),
});

export type ComparisonSignature = z.infer<typeof comparisonSignatureSchema>;

/**
 * Workflow - A discrete unit of work with classification (replaces Chapter in V2)
 */
export const workflowV2Schema = z.object({
  id: z.string(),
  // LLM-generated summary synthesized from semantic_steps descriptions
  workflow_summary: z.string(),
  classification: workflowClassificationSchema,
  timestamps: z.object({
    start: z.string(),
    end: z.string(),
    duration_ms: z.number(),
  }),
  comparison_signature: comparisonSignatureSchema,
  semantic_steps: z.array(semanticStepSchema),
  inefficiencies: z.array(workflowInefficiencySchema).optional(),
  recommendations: z.array(workflowRecommendationSchema).optional(),
});

export type WorkflowV2 = z.infer<typeof workflowV2Schema>;

/**
 * Session meta information for V2 schema
 */
export const sessionMetaSchema = z.object({
  total_duration_minutes: z.number(),
  user_id: z.string().nullish(),
});

export type SessionMeta = z.infer<typeof sessionMetaSchema>;

/**
 * Session summary V2 - Workflow-centric structure with 5-tier classification
 */
export const sessionSummaryV2Schema = z.object({
  schema_version: z.literal(2),
  session_meta: sessionMetaSchema,
  workflows: z.array(workflowV2Schema),
  // Keep highLevelSummary for backwards compatibility
  highLevelSummary: z.string().optional(),
});

export type SessionSummaryV2 = z.infer<typeof sessionSummaryV2Schema>;

/**
 * Union schema accepting both V1 (chapters) and V2 (workflows) formats
 */
export const sessionSummaryUnionSchema = z.union([
  sessionSummarySchema,
  sessionSummaryV2Schema,
]);

export type SessionSummaryUnion = z.infer<typeof sessionSummaryUnionSchema>;

/**
 * Detect schema version from a summary object
 */
export function detectSchemaVersion(summary: unknown): 1 | 2 {
  if (typeof summary !== 'object' || summary === null) return 1;
  const obj = summary as Record<string, unknown>;
  if (obj.schema_version === 2 || obj.workflows) return 2;
  if (obj.chapters) return 1;
  return 1;
}

/**
 * Type guard for V1 schema
 */
export function isV1Schema(summary: unknown): summary is SessionSummary {
  return detectSchemaVersion(summary) === 1;
}

/**
 * Type guard for V2 schema
 */
export function isV2Schema(summary: unknown): summary is SessionSummaryV2 {
  return detectSchemaVersion(summary) === 2;
}

// ============================================================================
// WORK TRACK SCHEMAS (Goal-Oriented Track Matching)
// ============================================================================

/**
 * Journey Info - The parent role/context container
 * (e.g., "Founder", "Research Assistant at Company X", "Masters at University Y")
 */
export const journeyInfoSchema = z.object({
  id: z.string().uuid(),
  title: z.string(),
  type: z.nativeEnum(TimelineNodeType),
  description: z.string().optional(),
});

export type JourneyInfo = z.infer<typeof journeyInfoSchema>;

/**
 * Work Track - A goal-oriented grouping of related sessions
 * (e.g., "Desktop MVP Release", "Series A Fundraising")
 * Work Tracks are CHILDREN of Journey nodes.
 */
export const workTrackSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(200),
  description: z.string().max(1000).optional(),
  archetype: z.nativeEnum(WorkTrackArchetype),
  templateType: z.nativeEnum(TrackTemplateType).optional(),
  status: z.enum(['active', 'completed', 'paused', 'archived']).default('active'),
  // Parent journey reference
  parentJourneyId: z.string().uuid().optional(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  // Aggregated stats
  totalSessions: z.number().optional(),
  totalDurationSeconds: z.number().optional(),
  lastActivityAt: z.string().datetime().optional(),
});

export type WorkTrack = z.infer<typeof workTrackSchema>;

/**
 * Simplified work track info for LLM context and matching
 */
export const workTrackInfoSchema = z.object({
  id: z.string().uuid(),
  title: z.string(),
  description: z.string().optional(),
  archetype: z.nativeEnum(WorkTrackArchetype),
  templateType: z.nativeEnum(TrackTemplateType).optional(),
  parentJourneyId: z.string().uuid().optional(),
  lastActivityAt: z.string().datetime().optional(),
});

export type WorkTrackInfo = z.infer<typeof workTrackInfoSchema>;

/**
 * LLM classification result for track matching
 * This is the structured output from the "Chief of Staff" LLM prompt
 * 
 * Three-Level Classification:
 * - Level 1: Journey (The Role/Context) - identifies the parent container
 * - Level 2: Track (The Project/Initiative) - specific work track under the journey
 * - Level 3: Template (The Visualization) - how to present the aggregated sessions
 */
export const trackMatchingResultSchema = z.object({
  // Level 1: Journey/Role identification
  targetJourneyId: z.string().uuid().nullable(),
  suggestedJourneyTitle: z.string().max(200).nullable(),
  
  // Level 2: Track matching decision
  targetTrackId: z.string().uuid().nullable(),
  suggestedNewTrackTitle: z.string().max(200).nullable(),
  trackArchetype: z.nativeEnum(WorkTrackArchetype),
  
  // Level 3: Visualization template
  recommendedTemplate: z.nativeEnum(TrackTemplateType),
  
  // Activity classification (secondary metadata for analytics)
  activityCategory: z.nativeEnum(WorkTrackCategory),
  
  // Narrative contribution - progress made in this session
  narrativeContribution: z.string().max(500),
  
  // Confidence and reasoning
  confidence: z.number().min(0).max(1),
  reasoning: z.string().max(500).optional(),
});

export type TrackMatchingResult = z.infer<typeof trackMatchingResultSchema>;

/**
 * Work track matching action types
 */
export const WorkTrackMappingAction = {
  MatchedExisting: 'matched_existing',
  CreatedNew: 'created_new',
  UserSelected: 'user_selected',
  DefaultedToGeneral: 'defaulted_to_general',
} as const;

export type WorkTrackMappingActionType = typeof WorkTrackMappingAction[keyof typeof WorkTrackMappingAction];

/**
 * Result of the work track matching process
 * Includes both the Journey (parent) and Track (child) context
 */
export const workTrackMappingResultSchema = z.object({
  action: z.enum(['matched_existing', 'created_new', 'user_selected', 'defaulted_to_general']),
  
  // Journey (parent container) - the role/context
  journeyId: z.string().uuid(),
  journey: journeyInfoSchema.optional(),
  
  // Work Track (child) - specific initiative under the journey
  trackId: z.string().uuid(),
  track: workTrackInfoSchema.optional(),
  
  // Template for visualization
  templateType: z.nativeEnum(TrackTemplateType).optional(),
  
  confidence: z.number().min(0).max(1),
  alternativeTracks: z.array(workTrackInfoSchema).optional(),
  alternativeJourneys: z.array(journeyInfoSchema).optional(),
  narrativeContribution: z.string().max(500),
});

export type WorkTrackMappingResult = z.infer<typeof workTrackMappingResultSchema>;

// ============================================================================
// SCREENSHOT DESCRIPTION SCHEMAS (for granular insight generation)
// ============================================================================

/**
 * Individual screenshot description from desktop app's Gemini Vision analysis
 */
export const screenshotDescriptionSchema = z.object({
  description: z.string(),
  app: z.string().optional(),
  category: z.string().optional(),
  isMeaningful: z.boolean(),
  ocrText: z.string().max(3000).nullable(),
  hasOcr: z.boolean(),
  appName: z.string().nullable(),
  windowTitle: z.string().max(1000).nullable(),
  browserUrl: z.string().max(2500).nullable(),
});

export type ScreenshotDescription = z.infer<typeof screenshotDescriptionSchema>;

/**
 * Map of screenshot descriptions keyed by timestamp
 * Only includes meaningful screenshots to reduce payload size
 */
export const screenshotDescriptionsSchema = z.record(
  z.string(), // timestamp key
  screenshotDescriptionSchema
).nullable().optional();

export type ScreenshotDescriptions = z.infer<typeof screenshotDescriptionsSchema>;

// ============================================================================
// GAP ANALYSIS SCHEMA
// ============================================================================

const timeAllocationCategorySchema = z.object({
  minutes: z.number(),
  percentage: z.number(),
  description: z.string(),
});

export const gapAnalysisSchema = z.object({
  sessionStructure: z.object({
    totalScreenshots: z.number(),
    sessionDurationMinutes: z.number(),
    captureIntervalSeconds: z.number(),
    applicationsUsed: z.array(z.string()),
    sessionType: z.string(),
  }),
  timelineReconstruction: z.array(z.object({
    timeStart: z.string(),
    timeEnd: z.string(),
    app: z.string(),
    durationSeconds: z.number(),
    activity: z.string(),
  })),
  goalIdentification: z.object({
    primaryGoal: z.string(),
    secondaryGoals: z.array(z.string()),
    expectedDeliverable: z.string(),
  }),
  sourceMaterialAudit: z.object({
    materialsConsulted: z.array(z.string()),
    toolsAvailableButUnused: z.array(z.string()),
    missedContext: z.array(z.string()),
  }),
  outputAssessment: z.object({
    actualOutput: z.string(),
    completenessScore: z.number(),
    qualityNotes: z.string(),
  }),
  timeAllocation: z.object({
    usefulWork: timeAllocationCategorySchema,
    wastedEffort: timeAllocationCategorySchema,
    contextSwitching: timeAllocationCategorySchema,
    navigationOverhead: timeAllocationCategorySchema,
    idleTransition: timeAllocationCategorySchema,
  }),
  stepByStepRecommendations: z.array(z.object({
    stepNumber: z.number(),
    timeRange: z.string(),
    app: z.string(),
    assessment: z.enum(['good', 'warning', 'bad']),
    whatHappened: z.string(),
    whatShouldHaveDone: z.string(),
    timeSavedSeconds: z.number(),
    recommendation: z.string(),
  })),
  significantImprovements: z.array(z.object({
    title: z.string(),
    description: z.string(),
    impactLevel: z.enum(['HIGH', 'MEDIUM', 'LOW']),
    estimatedTimeSavingsMinutes: z.number(),
    implementationDifficulty: z.enum(['EASY', 'MODERATE', 'HARD']),
    implementationSteps: z.array(z.string()),
  })),
  overallEfficiencyScore: z.number(),
  summaryOfGaps: z.string(),
}).nullable().optional();

export type GapAnalysis = z.infer<typeof gapAnalysisSchema>;

// ============================================================================
// PUSH SESSION API SCHEMAS
// ============================================================================

/**
 * Request schema for pushing a session from desktop app
 * This is what the desktop app sends when user clicks "Push Session"
 */
export const pushSessionRequestSchema = z.object({
  // From desktop app (existing payload structure)
  sessionId: z.string().min(1, 'Session ID is required'),
  workflowName: z.string().min(1, 'Workflow name is required'),
  startTime: z.number().positive('Start time must be a positive timestamp'),
  endTime: z.number().positive('End time must be a positive timestamp'),

  // AI-generated summary from desktop app's screenshot analysis
  // Accepts both V1 (chapters) and V2 (workflows) formats
  summary: sessionSummaryUnionSchema,

  // Apps used during the session
  appsUsed: z.array(z.string()).optional().default([]),

  // User edits to the summary (if any)
  userEdits: z.record(z.any()).optional(),

  // Optional: User pre-selected node (current manual flow)
  // If provided, we use this directly instead of auto-matching
  journeyNodeId: z.string().uuid().optional(),
  projectId: z.string().uuid().optional(),

  // Optional: Desktop app can suggest a category based on local analysis
  suggestedCategory: z.nativeEnum(WorkTrackCategory).optional(),

  // Optional: User-provided notes to improve summary accuracy
  // These notes are context, goals, or details the user added to help the AI
  userNotes: z.string().max(2000).nullable().optional(),

  // Optional: Screenshot-level descriptions for granular insight generation
  // Contains detailed descriptions of what happened in each meaningful screenshot
  screenshotDescriptions: screenshotDescriptionsSchema,

  // Optional: Deep gap & improvement analysis from Gemini Vision
  gapAnalysis: gapAnalysisSchema,

  // Optional: Session insights generated by Gemini (at-a-glance, issues, improvements)
  insights: z.record(z.any()).nullable().optional(),

  // Optional: Peer insights fetched from backend API
  peerInsights: z.array(z.record(z.any())).nullable().optional(),

  // Optional: Pre-computed context stitching (3-tier cumulative analysis)
  // Generated during desktop analyzing phase via POST /api/v2/sessions/stitch-context
  stitchedContext: z.record(z.any()).nullable().optional(),
});

export type PushSessionRequest = z.infer<typeof pushSessionRequestSchema>;

/**
 * Classification result returned in push response
 * Now includes three-level classification: Journey → Track → Template
 */
export const classificationResultSchema = z.object({
  // Activity category (secondary tag for analytics)
  category: z.nativeEnum(WorkTrackCategory),
  confidence: z.number().min(0).max(1),
  nodeType: z.nativeEnum(TimelineNodeType),
  signals: z.array(z.string()), // What triggered this classification
  
  // Track-level classification (primary grouping)
  trackArchetype: z.nativeEnum(WorkTrackArchetype).optional(),
  
  // Template type for visualization
  templateType: z.nativeEnum(TrackTemplateType).optional(),
  
  narrativeContribution: z.string().max(500).optional(),
});

export type ClassificationResult = z.infer<typeof classificationResultSchema>;

/**
 * Timeline node summary for response
 */
export const nodeInfoSchema = z.object({
  id: z.string().uuid(),
  type: z.nativeEnum(TimelineNodeType),
  title: z.string(),
  meta: z.record(z.any()).optional(),
});

export type NodeInfo = z.infer<typeof nodeInfoSchema>;

/**
 * Node mapping result returned in push response
 */
export const nodeMappingResultSchema = z.object({
  action: z.nativeEnum(SessionMappingAction),
  nodeId: z.string().uuid(),
  node: nodeInfoSchema.optional(),
  confidence: z.number().min(0).max(1),
  alternativeNodes: z.array(nodeInfoSchema).optional(), // Top 3 alternatives for user review
});

export type NodeMappingResult = z.infer<typeof nodeMappingResultSchema>;

/**
 * Response schema for push session endpoint
 */
export const pushSessionResponseSchema = z.object({
  success: z.boolean(),
  sessionMappingId: z.string().uuid(),

  // Classification result (includes both activity and track-level info)
  classification: classificationResultSchema,

  // Node mapping result (legacy - for backward compatibility)
  nodeMapping: nodeMappingResultSchema,

  // Work track mapping result (primary grouping mechanism)
  trackMapping: workTrackMappingResultSchema.optional(),

  // For web viewing
  journeyUrl: z.string().url().optional(),
  message: z.string(),
});

export type PushSessionResponse = z.infer<typeof pushSessionResponseSchema>;

// ============================================================================
// RECLASSIFY/REMAP API SCHEMAS
// ============================================================================

/**
 * Request to reclassify a session into a different category
 */
export const reclassifySessionRequestSchema = z.object({
  newCategory: z.nativeEnum(WorkTrackCategory),
  reason: z.string().max(500).optional(), // For RLHF learning
});

export type ReclassifySessionRequest = z.infer<
  typeof reclassifySessionRequestSchema
>;

/**
 * Request to remap a session to a different node
 */
export const remapSessionRequestSchema = z.object({
  newNodeId: z.string().uuid(),
  reason: z.string().max(500).optional(), // For RLHF learning
});

export type RemapSessionRequest = z.infer<typeof remapSessionRequestSchema>;

/**
 * Response for reclassify/remap operations
 */
export const sessionUpdateResponseSchema = z.object({
  success: z.boolean(),
  sessionMappingId: z.string().uuid(),
  feedbackId: z.string().uuid(), // ID of the feedback record created
  message: z.string(),
});

export type SessionUpdateResponse = z.infer<typeof sessionUpdateResponseSchema>;

// ============================================================================
// SESSION LIST/GET API SCHEMAS
// ============================================================================

/**
 * Query parameters for listing sessions
 */
export const listSessionsQuerySchema = z.object({
  page: z.coerce.number().positive().default(1),
  limit: z.coerce.number().positive().max(100).default(20),
  category: z.nativeEnum(WorkTrackCategory).optional(),
  nodeId: z.string().uuid().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
});

export type ListSessionsQuery = z.infer<typeof listSessionsQuerySchema>;

/**
 * Session mapping item in list response
 */
export const sessionMappingItemSchema = z.object({
  id: z.string().uuid(),
  desktopSessionId: z.string(),
  category: z.nativeEnum(WorkTrackCategory),
  categoryConfidence: z.number().nullable(),
  nodeId: z.string().uuid().nullable(),
  nodeTitle: z.string().optional(),
  nodeType: z.nativeEnum(TimelineNodeType).optional(),
  workflowName: z.string().nullable(),
  highLevelSummary: z.string().nullable(),
  generatedTitle: z.string().nullable(),
  startedAt: z.string().datetime().nullable(),
  endedAt: z.string().datetime().nullable(),
  durationSeconds: z.number().nullable(),
  mappingAction: z.nativeEnum(SessionMappingAction).nullable(),
  createdAt: z.string().datetime(),
  // Optional chapters from node.meta (included when fetching full session details) - V1 format
  chapters: z.array(sessionChapterSchema).optional(),
  // Optional workflows from node.meta (included when fetching full session details) - V2 format
  workflows: z.array(workflowV2Schema).optional(),
  // Schema version indicator (1 = chapters, 2 = workflows)
  schemaVersion: z.union([z.literal(1), z.literal(2)]).optional(),
  // Whether this session is shared with peers (for per-session scope)
  peerSharingEnabled: z.boolean().optional(),
});

export type SessionMappingItem = z.infer<typeof sessionMappingItemSchema>;

/**
 * Response for listing sessions
 */
export const listSessionsResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    sessions: z.array(sessionMappingItemSchema),
    pagination: z.object({
      page: z.number(),
      limit: z.number(),
      total: z.number(),
      hasNext: z.boolean(),
      hasPrev: z.boolean(),
    }),
  }),
});

export type ListSessionsResponse = z.infer<typeof listSessionsResponseSchema>;

// ============================================================================
// CATEGORIES API SCHEMAS
// ============================================================================

/**
 * Category definition for UI display
 */
export const categoryDefinitionSchema = z.object({
  value: z.nativeEnum(WorkTrackCategory),
  label: z.string(),
  nodeType: z.nativeEnum(TimelineNodeType),
  group: z.string(),
});

export type CategoryDefinition = z.infer<typeof categoryDefinitionSchema>;

/**
 * Response for categories endpoint
 */
export const categoriesResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    categories: z.array(categoryDefinitionSchema),
    groups: z.array(
      z.object({
        key: z.string(),
        label: z.string(),
        categories: z.array(z.nativeEnum(WorkTrackCategory)),
      })
    ),
  }),
});

export type CategoriesResponse = z.infer<typeof categoriesResponseSchema>;

// ============================================================================
// FEEDBACK API SCHEMAS
// ============================================================================

/**
 * Request to submit RLHF feedback
 */
export const submitFeedbackRequestSchema = z.object({
  sessionMappingId: z.string().uuid(),
  feedbackType: z.nativeEnum(SessionFeedbackType),
  originalCategory: z.nativeEnum(WorkTrackCategory),
  correctedCategory: z.nativeEnum(WorkTrackCategory).optional(),
  originalNodeId: z.string().uuid().optional(),
  correctedNodeId: z.string().uuid().optional(),
  userRole: z.string().max(100).optional(),
  reason: z.string().max(500).optional(),
});

export type SubmitFeedbackRequest = z.infer<typeof submitFeedbackRequestSchema>;

/**
 * Response for feedback submission
 */
export const submitFeedbackResponseSchema = z.object({
  success: z.boolean(),
  feedbackId: z.string().uuid(),
  message: z.string(),
});

export type SubmitFeedbackResponse = z.infer<
  typeof submitFeedbackResponseSchema
>;

// ============================================================================
// NODE SESSIONS API SCHEMAS
// ============================================================================

/**
 * Query params for getting sessions by node
 */
export const nodeSessionsQuerySchema = z.object({
  page: z.coerce.number().positive().default(1),
  limit: z.coerce.number().positive().max(50).default(10),
});

export type NodeSessionsQuery = z.infer<typeof nodeSessionsQuerySchema>;

/**
 * Response for getting sessions mapped to a node
 */
export const nodeSessionsResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    nodeId: z.string().uuid(),
    sessions: z.array(sessionMappingItemSchema),
    totalDurationSeconds: z.number(),
    sessionCount: z.number(),
    pagination: z.object({
      page: z.number(),
      limit: z.number(),
      total: z.number(),
      hasNext: z.boolean(),
      hasPrev: z.boolean(),
    }),
  }),
});

export type NodeSessionsResponse = z.infer<typeof nodeSessionsResponseSchema>;


